Um den One-Location Rowhammer zu testen, haben wir drei Schritte vorgenommen. Zuerst haben wir versucht, unsere eigene Version des One-Location Rowhammer zu implementieren. Diese Implementation findet sich als \emph{myrowhammer.cc}. Dann haben wir unsere Implementation mit der Originalimplementation \cite{git-rowhammer} verglichen und auf den Double-Sided Rowhammer Bezug genommen.\\
In unserer Implementation allokieren wir uns zunächst einen Teil des Speichers. Dann laden wir in den Speicher Werte. Diese sollten sowohl zufällig sein, damit wir Bitflips von 0 nach 1 sowie andersherum erzeugen können. Aber sie sollten ebenfalls leicht wiederzuerkennen sein, damit wir einen Bitflip nachher leicht feststellen können. Dafür besteht jedes unserer Arrays aus acht Bytes welche entweder nur aus Nullen oder nur aus Einsen bestehen. Welches der Fall ist, wird für jedes zufällig gewählt.
Dann wählen wir eine zufällige Position im allokierten Speicher und greifen wiederholt darauf zu. Der Standardwert dabei sind 5000000 Zugriffe. Dann wird überprüft, ob dadurch im allokierten Speicher Änderungen aufgetreten sind. Wenn dies der Fall ist, dann haben wir einen Bit-Flip erzeugt. Da hierbei der größte Aufwand beim Vergleich des Speichers entsteht, werden gleich mehrere Arrays im Speicher gehämmert. Dies steht zwar leicht im Widerspruch zum Namen des One-Location Rowhammer, erhöht aber die Möglichkeit, einen Bitflip zu erzeugen.

\subsubsection{Durchführbarkeit}
Beide Arten des Rowhammer-Angriffes sind prinzipiell immer durchführbar, sofern keine Maßnahmen in der Hardware vorgenommen werden, um Bitflips explizit zu vermeiden oder zu erkennen. Es hängt jedoch stark von dem verwendetem Speicher ab, mit welcher Häufigkeit ein solcher Bitflip auftreten kann. Durch die Tatsache, dass wir auf einigen unserer Testrechner mit dem Double-Sided Rowhammer einen Bitflip erzeugen konnten, zeigt, dass es prinzipiell möglich ist, auf diesem Rechner einen Rowhammer-Angriff auszuführen.

\subsubsection{Zuverlässigkeit}
Die Zuverlässigkeit dieses Angriffes ist nicht gegeben. Zum einen ist es nicht gegeben, dass man bei der  einfachen Allokierung beim One-Location Rowhammer Speicher erhält, welcher sich gegenseitig beeinflusst. Dementsprechend muss man genügend viel Speicher allokieren. Selbst wenn man dann solchen Speicher gegeben hat, ist die Chance, dass Bitflips dabei entstehen äußerst gering. Dementsprechend muss man dann oft genug hämmern und hoffen, dass dann dadurch Bitflips entstehen. Damit ist das Erzeugen eines bestimmten Bitflips im Allgemeinen nicht reproduzierbar. Wenn man jedoch genug Ressourcen, Speicher und Zeit zur Verfügung stellt, kann man auf einem verwundbaren System wiederholt Bitflips erzeugen.

\subsubsection{Schnelligkeit}
Mit beiden Implementationen des One-Location Rowhammer konnten keine Bitflips gefunden werden. Wir haben die Implementationen auf den Testrechnern bis zu vier Stunden oder 10000 Hammer-Versuchen laufen lassen, ohne einen Bitflip zu finden. Dabei hat die Originalimplementation jedoch stets mehr Hammer-Versuche hinbekommen als unsere Implementation. Das Hämmern eines Wertes dauert im Durchschnitt 0.98 Sekunden und die Überprüfung eines Speicher der Größe von vier Gigabyte dauert 2,8 Sekunden. Der Double-Sided Rowhammer hat es in einigen Testläufen geschafft nach einer halben Stunde einen Bitflip zu finden, in anderen Fällen war auch jener nach drei Stunden ohne einen einzigen Bitflip.
\subsubsection{Unauffälligkeit}
Die Unauffälligkeit dieser Angriffe steht im Gegensatz zu Schnelligkeit. Wenn wir dem Angriff den gesamten Speicher zur Verfügung stellen, könnte auffallen, dass ein Prozess viel Speicher benötigt. Aber die Trennung, dass jenes ein böswilliger Angriff ist und nicht nur ein harmloser Prozess, der gerade viel Speicher benötigt ist nicht trivial. Die CPU-Auslastung für diesen Angriff ist äußerst gering. Hierbei wird zwar die gesamte Zeit auf den Speicher zugegriffen, aber dies benötigt nur eine geringe Menge an Ressourcen.
